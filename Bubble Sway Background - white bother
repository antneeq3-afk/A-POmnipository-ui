import React, { useEffect, useRef } from "react";

const BUBBLE_COUNT = 150;

export default function SmoothSwayStage() {
  const containerRef = useRef(null);
  const bubblesRef = useRef([]);

  useEffect(() => {
    // 1. Initialize bubble data with drift and phase
    const data = Array.from({ length: BUBBLE_COUNT }).map((_, i) => ({
      x: Math.random() * 100,
      y: Math.random() * 100,
      vx: (Math.random() - 0.5) * 0.01,
      vy: (Math.random() - 0.5) * 0.01,
      size:
        Math.random() > 0.3 ? Math.random() * 60 + 30 : Math.random() * 20 + 5,
      opacity: Math.random() * 0.3 + 0.1,
      phase: Math.random() * Math.PI * 2,
      element: null,
    }));

    // 2. Create DOM elements
    data.forEach((b) => {
      const el = document.createElement("div");
      Object.assign(el.style, {
        position: "absolute",
        width: `${b.size}px`,
        height: `${b.size}px`,
        borderRadius: "50%",
        background:
          "radial-gradient(circle at 35% 30%, rgba(255,255,255,0.45) 0%, rgba(255,255,255,0.05) 40%, transparent 70%)",
        boxShadow:
          "inset -4px -4px 12px rgba(255,255,255,0.15), inset 2px 2px 8px rgba(255,255,255,0.2)",
        border: "0.8px solid rgba(255,255,255,0.25)",
        opacity: b.opacity,
        pointerEvents: "none",
        zIndex: 5,
        willChange: "transform",
      });
      containerRef.current.appendChild(el);
      b.element = el;
    });

    bubblesRef.current = data;

    let frameId;
    let time = 0;

    const animate = () => {
      time += 0.004; // Gentle oscillation speed
      const bubbles = bubblesRef.current;

      for (let i = 0; i < bubbles.length; i++) {
        const b1 = bubbles[i];

        // Physics: Repulsion (The "Push")
        for (let j = i + 1; j < bubbles.length; j++) {
          const b2 = bubbles[j];
          const dx = b1.x - b2.x;
          const dy = b1.y - b2.y;
          const distSq = dx * dx + dy * dy;
          const minDist = (b1.size + b2.size) / 28;
          const minDistSq = minDist * minDist;

          if (distSq < minDistSq) {
            const dist = Math.sqrt(distSq) || 1;
            const force = (minDist - dist) * 0.0004;
            b1.vx += (dx / dist) * force;
            b1.vy += (dy / dist) * force;
            b2.vx -= (dx / dist) * force;
            b2.vy -= (dy / dist) * force;
          }
        }

        // The Sway: Consistent horizontal drift
        b1.vx += Math.sin(time + b1.phase) * 0.0002;

        b1.vx *= 0.98;
        b1.vy *= 0.98;
        b1.x += b1.vx;
        b1.y += b1.vy;

        // Wrap-around logic for continuous flow
        if (b1.x < -10) b1.x = 110;
        if (b1.x > 110) b1.x = -10;
        if (b1.y < -10) b1.y = 110;
        if (b1.y > 110) b1.y = -10;

        b1.element.style.transform = `translate3d(${b1.x}vw, ${b1.y}vh, 0) translate(-50%, -50%)`;
      }

      frameId = requestAnimationFrame(animate);
    };

    frameId = requestAnimationFrame(animate);
    return () => {
      cancelAnimationFrame(frameId);
      if (containerRef.current) containerRef.current.innerHTML = "";
    };
  }, []);

  return (
    <div style={stageContainer}>
      <div style={originalGradientBackdrop} />
      <div ref={containerRef} style={bubbleOverlay} />

      {/* FIXED LIGHT: Using Linear Gradient to avoid the "Spot" entirely */}
      <div style={linearSurfaceWash} />

      <div style={labelStyle}>
        THE SKELETON
        <br />
        <span style={{ fontSize: "0.8rem", opacity: 1, fontWeight: 500 }}>
          PART 1: ZERO-SPOT SWAY MASTER
        </span>
      </div>
    </div>
  );
}

// --- STYLES ---
const stageContainer = {
  position: "fixed",
  inset: 0,
  overflow: "hidden",
  background: "#075985",
};

const originalGradientBackdrop = {
  position: "absolute",
  inset: 0,
  zIndex: 1,
  background:
    "linear-gradient(to bottom, #7dd3fc 0%, #0ea5e9 35%, #0369a1 75%, #075985 100%)",
};

const bubbleOverlay = {
  position: "absolute",
  inset: 0,
  zIndex: 10,
  pointerEvents: "none",
};

const linearSurfaceWash = {
  position: "absolute",
  inset: 0,
  zIndex: 15,
  // Linear gradient has no "center spot" to glitch out
  background:
    "linear-gradient(to bottom, rgba(255,255,255,0.3) 0%, transparent 40%)",
  pointerEvents: "none",
};

const labelStyle = {
  position: "absolute",
  bottom: "60px",
  width: "100%",
  textAlign: "center",
  color: "white",
  letterSpacing: "4px",
  fontWeight: "900",
  zIndex: 20,
};
